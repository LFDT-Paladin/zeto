package util

import (
	"encoding/hex"
	"math/big"
	"testing"

	"github.com/iden3/go-rapidsnark/types"
	"github.com/stretchr/testify/assert"
)

func TestEncodeToBytes_Anon(t *testing.T) {
	// Create a mock proof structure
	proof := &types.ProofData{
		A: []string{
			"19419894181753946885905644368046847329207765137646602665981849849988177743059",
			"8860978609790168474767280492049619889501902847625004440136511955001364468415",
		},
		B: [][]string{
			{
				"9615575088076752629397084217945947779665289892224135440531875614084365249217",
				"8718550324938987957095508092102403533235190813736638001821208030813968638254",
			},
			{
				"4507949473085915953198782111072352449926955230934371249989726205978821319356",
				"2606785578797556551529006970822259402011711298405435930848444219387480770792",
			},
		},
		C: []string{
			"10447661281555614767826338373521147852467370112423332977409468234577352614898",
			"6920596160795468120428710510209510475789771793984566256082007483448385924774",
		},
	}

	// Test encoding
	encodedBytes, err := EncodeToBytes_Anon(proof)

	// Assertions
	assert.NoError(t, err)
	assert.NotNil(t, encodedBytes)
	expected := "2aef45457254c6b207811c860ff4474360a1353613c7100f1e718fabcb884cd3139722db9afdb3d7ce13a5e5eb9cffcb3dbd0c89d56bfdc13e576062b97052bf1346864ce74636589726924b7378aff0bcb1c92a1d204f7bbfb500b58143a12e154238fe9745e67da3ccad55587c8aae45cf9b6204eb24224a35ee4599576ac105c3636b0624515971c23b703549f177ffe91da43acfaf0b938da56340a208e809f768b3202645dc8d02935e8ac99e1e9a1b9a21b7059c0b071ea5baf35cdabc17192aaedbc35296f6650dcee762ab5a0d19876b06c07f5893d881fb3a0c63f20f4ceb2a75e0e80ecd017db6f9d640e1697b80d0a35ec73483529e9e4ec4eea6"
	assert.Equal(t, expected, hex.EncodeToString(encodedBytes))
}

func TestEncodeToBytes_Nullifier(t *testing.T) {
	root, _ := new(big.Int).SetString("10759239749463985685121762721989308290835056358617431948062611695492264476410", 10)
	proof := &types.ProofData{
		A: []string{
			"5328072594108987804127855328072854874198842515599920751075487212321476773267",
			"7147483474308145552276544004876198902352123441865200921645558203768611789165",
		},
		B: [][]string{
			{
				"461122944375069029505337964856327144648841536253939239066450196477531324775",
				"15625624763887797235376996601604680687875812728664388155294150592552080812680",
			},
			{
				"8586270950772636464799150771428148215747494130795023929229678833856408392651",
				"6152378699065869188893238643158305047171335687223678471072368088033358986813",
			},
		},
		C: []string{
			"13749967294589009225936444458669907245547655267950737219661092984298998163440",
			"19318867056102586691848912731873189530599099780973209315762798285028802995521",
		},
	}

	// Test encoding
	encodedBytes, err := EncodeToBytes_Nullifier(root, proof)
	assert.NoError(t, err)
	assert.NotNil(t, encodedBytes)
	expected := "17c9838e8de82e8e786853505d7e0fc9604cf2c10857c3775880e2e0d8d9befa0bc7950c5fb023af0ab7a679147f0409a5ec744082b1efbe1d6bbc20b97d05930fcd5510a5fdda4a31af34ef8d74ce01772f020b51a8c44b31f2f5a958f7d96d228bca4ad3518bbab9ef2b19feb91a2a73b198fc433c778bea6d8570a050aa880104fc809d700ccc7e930e36ce573e0fc64ba83823d307817b06e3fa748b01670d9a1f791e8cabf2e26fef2d29141006b2e842e38ab1e62ec3c960ffa4ef3e3d12fba83a3882cec5154c2105f4ad578ff7ca808ba60d02bfccf2fb7bc6cf13cb1e6634a89bc0636a755e174a03f8e03e3c3b81a198a305a62c7f3e97088d67f02ab6175d168c9d859db0a0263dc76ea4116324f7d92e91fb793ec0c17ad8a541"
	assert.Equal(t, expected, hex.EncodeToString(encodedBytes))
}

func TestEncodeToBytes_Qurrency(t *testing.T) {
	root, _ := new(big.Int).SetString("10775511825316780085995526169481784138221921243614872072713961410119594620922", 10)
	encryptionNonce, _ := new(big.Int).SetString("146086364555214349570504081522936027738", 10)
	cipherTextStrs := []string{
		"8521465373625944663507220861350266515443566872236002804444201373940064475255",
		"11730541828259389390937507588781712999513601599260313054217450846914079421466",
		"20749105918004420441187060759156540279234681523991973066814790392634102586276",
		"2734463142173660691877054884974336008812850620713307186712514087660449275623",
		"4150355575076862498727697122477717385208337992249558503039272348677722470034",
		"8267105246445154604000920070127571255109299747397192821191374066353440238835",
		"16822752436454150114526563798639641051008541942991822753563368190454117277716",
		"17655007980813021681563110568242322715819547410199790426384752148428424740290",
		"21093561119542476424389686735487650745985477511405559487968575872446268778412",
		"15258409253852504676701787496722400081403614515482297722644071975193657127977",
		"12448340009883842814443351516967809780707198227630327226526798465728772985639",
		"17030033007091862525781711906474788549572263348281463875514141432382190273547",
		"19552749256145330747740280799523155541733266547208815012888538580610085527223",
		"9127253020665905585215819914893252937814390028989647274689588871734018669489",
		"15473804943102768794468027402470982281892413346371816115529125255205310508420",
		"2260117899623922442466502319761646238380424533213838111452228603968454286886",
	}
	encryptedValues := make([]*big.Int, len(cipherTextStrs))
	for i, str := range cipherTextStrs {
		encryptedValues[i], _ = new(big.Int).SetString(str, 10)
	}
	encapsulatedSharedSecretStrs := []string{
		"417093403216325732918602641137054449674304716626480338298088305546965914809",
		"429834105520591236795631755384620855265339086075424066082234426021725411560",
		"55819258410752669507431554113344248547669162029886028819776606402652477513",
		"2247430981538956571158134865590908223510373286269299572372690090335574533",
		"393997999783131301252416196955196386311456389441691251652195855756446071226",
		"142072573788224706174546948730707887820898830776735085139172518836546146837",
		"347376486321318701971361621898303357417850365774752773770338833488067881864",
		"318308420244471164371742113488804590003381512236049659743359627785482658926",
		"396748838519206643525234340528813406733388992435434057039531329618176775574",
		"149441523545699048509764134460726685795587235346244054597044277268024346508",
		"324087503848705690630241701188221536325605579898174684656123366893903273701",
		"197521041095815324433814292345044456618723573914553975056584319879168989494",
		"12288441064089298983056733377313251211298748114994889084261563973431879301",
		"73304596161171990391299291602657718580516977874213216858576714455839668221",
		"398907037264677722289221013859777428925096604345689941907143225470926421850",
		"219791995940531378276549090421763304793306351891836187613477055671526562010",
		"366476626188690874361007599814796615441638027911258947082742499266979870773",
		"372019334859722245026347166627553165365015449159776227270778306626007685243",
		"291462287975012857516876297098117697310078196384960841872272970065535172203",
		"114253405065606624823337038524153872812338161452896676978405158582638271747",
		"184654919088808450091096207227329931177654656418222751784858252626950887897",
		"346139045014545860011971316226494299506554164826187895554263572063796949622",
		"262323554622713871144071704855183862972213177554609766893616989014370620867",
		"16684092541543670920326067327828352439720714184216095761510226157344069619",
		"2803934077598065296131844184061870541001445846792810780855",
	}
	var encapsulatedSharedSecret [25]*big.Int
	for i, str := range encapsulatedSharedSecretStrs {
		encapsulatedSharedSecret[i], _ = new(big.Int).SetString(str, 10)
	}
	// Create a mock proof structure
	proof := &types.ProofData{
		A: []string{
			"15633062723300581395466913505943186768687099965061963877918854627019069352454",
			"14910802417108709959105218558983100084403495656852974898411749259688726219803",
		},
		B: [][]string{
			{
				"15772838776575386731074106296200820281819776942113302936637941220950962189544",
				"3685559734351853467821571769318676421241145601787818980617408213911026907474",
			},
			{
				"12281016305582935756199424098447407463986601274115114373961058913620577850257",
				"5692007718863890110797389084105614178505159058600187802641128195965755459126",
			},
		},
		C: []string{
			"6997423422194406037677999090967179188601947739824765321463196207803270470850",
			"18443090072922746622753441545384016447130110863091984503816183957001573020139",
		},
	}

	// Test encoding
	encodedBytes, err := EncodeToBytes_Qurrency(root, encryptionNonce, encryptedValues, encapsulatedSharedSecret, proof)
	assert.NoError(t, err)
	assert.NotNil(t, encodedBytes)
	expected := "17d2b93b6488040c7f7e2f9f3caf36d889319f19a94cd4a79da42112606b37fa000000000000000000000000000000006de735dc891b1db17984767b33389a5a000000000000000000000000000000000000000000000000000000000000048000ec11062a8cd53feca232e75f3d20688deea21e27318b0ef37965f6504194b900f347091468a9bcee03f87adfc1c934d8d176384cf154e863d15f32aa5518e8001f97b35dc1e34a1bf7e50ec2f1f4ebcd47048cb857cc0e793579ad74d11849000145a1d9239d89f088b94f9613751bfa093ecc43522f6def0f521743129a0500defeb60aa273b03fcd118cf61bc3ffb5002ffa227bcd29f1aa5addeabef9ba00506904a53875ac3c617e9b3bf8e25925725c1b10644ff7be57bd668ed1921500c49badff25e8d1c19dd5faa76fa709f269049e00802da457970c097232eb8800b427fb807a26e0f3003614761948405532b64ff994dba207684b8b5f29e46e00e08d485235ec98e69a75f5b9b2ba4f2672dea245df437e0cd11cef39ee1596005494b62edb95124f4c65964a7d3f77cea39ebe95467a3699965498e62b478c00b76d51a0597db523f1bcb2ad48e04089cdeee0fc7a2132c15c807f11e5dee5006fcafe9af035b81890dfb8e94f406621d1017e6ca02d1fc290c1b16b5119360006f47b9c9d2464adddb48a107dca6e710bbee4a9f4e31ee7f7e7b2c2e2668500297d2a96ec897315c50a2daaa83c1b216d84ac5fdfa73767f807de164ff7fd00e1c5fc5c9b695314b8925c4dcce60e082d912781f524192070fa85efc77f5a007c65da3b6dd8149c64947cf3024042fd9d03ae4d053b5237cef2037cc118da00cf6b1d8f3652fd8628bf1dc0a82db3bc7dfbbf7aed53cc58ef9693003ab83500d28e340ce49b27a03c1e6c05df88f719ac12c5a2f545adac25439404dd587b00a4f6391ccd06dfb6d2549e6c0e302da7c9b5f271b7e0a6930f4a8b56c9fe6b0040aa4653fbf4c232844d441d13c718983559cacd70f778d45dafee4e62dd03006882cf9dcbaacbb25773677f81ad9eb0e0073a5e4116fcf4f834c4b49419d900c3e862bf63626f29128567b033d21537ae6ad2672a69d0f1fed5e0fe1d7276009478496c3a7f03b62635987ef261db124083bfa477bf353e9f161eb37515c30009715f63013789f6e0fcdbc3400c52a0143d779cba580a69a37ca3ed3f17f30000000000000000725a700d51c61fa546e7f48e18658462461319c14b3fd8b7228ffffc12d0166bbc357026b055e44b90a29565d97a8a9b93a9930e04cc6a0620f737105f4b723598d15dcd62b9529678c4cacb4e53d145d1b52dd4efd7cc1b0825f3f05a951f80a372caab06c31e0f4847f46d42f67770374dc98e3da5b95222df1c4209eb2f1169ecf830730a3f22cdc91e0a2df7b6bf27d4c4232815b4e80c958fec67dc1972df952ce5107bfc5240d781170600f64835206573a62206361b26cf142c71887eac792b44115513fac1a83f3e18f5d963fd5a84d55a7d93910f7866bbf7369e475e30577b9f2a37b726dc70a1f0126f4a0f76dbe6a1949cc228c66b475c968508d264540c79dc9ef649584cbca08afb85578cd5fc1fd4b1eb000000000000000000000000000000000000000000000000000000000000001012d6fa7dc46957938d7a60b7b28c2a62d06335d7da193c5749bf79c4b680587719ef405b00b4beee7197e87726914bd7d6e049c6d7eded8b4d100372444cf41a2ddf93e8ec5b45d339a1dd1f13f8e73ea50d08aa90e49e108bf86a6926fd1ba4060ba6bb0ecb0f5f83155e3c8cb3e5977bb98f68c3fdfb86e7ef6d4f69dd9ee7092d049c44225c01a35915ea8bb2b81b4a92edbfcf431092d97c0d69714df6921247040848f23b9de925d9f7d939402af26899893b7866bc09f27e2df9f72cf325315728167f002997e5b897caf42da5f896c23102a4e7f13e71c243eee5a01427086161edbd6e0d3d1f0c27260fc46ada38ae2b95e47ac83d3287a1f0dffdc22ea2885271f0c3ed5a7cd66470367a0b427e9cfe6fcd387111fe3e311f4927ac21bbf41e8a7c1407b498f96747680367fc85890c9bdd0fabc62ed854fa62b4291b8582c14e1aaef5aeb1d13a930984f89874e64de93b97acf129fb38608e532725a6a837c35dc2275760a244a96a9b64b0500c16656694ac30ad8e9c6ed8440b2b3a76c209951eb9945f7b4ee537b579561048a51574c8cb73e607e3fc6f9eb7142dd7966e6c828ab0b74d9cb709e54eba945f4f36b68ae19f01cd1fd6d77bb12235dcfcb1e7ba7ab7ef3dc2149992aef23dec6431c296c04ea699c3e2512d8404ff2e702548865ebbff746dd22a972229a3b44fb36fb50f91293ca97fe65e26"
	assert.Equal(t, expected, hex.EncodeToString(encodedBytes))
}
